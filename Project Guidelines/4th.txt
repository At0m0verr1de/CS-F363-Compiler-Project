The following test cases and a few output samples are given for your reference.

t1.txt: This test case has lexemes following the given patterns and should be used to test your lexical analyzer. More patterns and unknown symbols can be added to verify the working of your lexer. The file lexemesandtokens_t1.txt displays the format and expected output of your lexer on the test case t1.txt. 
t2.txt: This test case is syntactically correct. How the output appears on the console on comment removal is shown in the file commentremoval_t2.txt. Note that the appearance of the source code does not change after the removal of the comments. The indentations, white spaces etc. in the non-commented lines and the line numbers of the code remain same after comment removal.  Also, the lexemes and tokens are displayed with line numbers in file lexemesandtokens_t2.txt.
t3.txt: This test case is syntactically correct. Ensure that your  parser works efficiently and produces the message for successful compilations as mentioned earlier. A parser creates the parse tree while in the parsing process. When the source code is syntactically correct in the given test case, the parser successfully builds the parse tree. Also, if in any test case there are syntactic errors, the parser recovers them and continues building the parse tree despite the fact that it lost a corresponding subtree while going for panic mode error recovery.
t4.txt: This test case is syntactically correct. 
t5.txt : This test case is syntactically correct. In case of any error, please inform me so that the error can be eliminated.
t6.txt: This test case has errors. All errors are required to be reported line number wise. The order of printing the errors may differ due to the heuristic used by the teams for error recovery. Also, the panic mode of recovery might skip some errors from being reported. Ensure that you report the maximum errors. Include the semicolon and a few keywords like endrecord, endunion, endif, endwhile, else, ), ] etc. in your synchronization set. This will give you better error reporting.  However, it is expected that you maintain the initial format  given in file listoferrors_t6.txt.  You can follow the same style of the error message or you may have your own message content that is self explanatory. Do not repeatedly report the same error multiple times at the same line number due to error recovery or any other issue. 
The teams are advised to create their own testcases handling all features given in the language specification document and as per the modified grammar.  I advise you to gradually go for larger and complex test cases starting with very simple 5 to 10 lines of code with very minimal set of features . Keep testing your modules with features added incrementally to the test case that you use while creating your lexer and parser. 

Another suggestion is to create larger test cases of about 400 to 600 lines, which you can use to test the efficiency of your compiler project code in terms of time and memory needs. If you re using twin buffer, try to have a small block size of 50 bytes for each buffer and test the refilling of the two buffers alternatively. A compiler developer should not take the whole memory at the disposal of the compiler program, and in case of very large user programs (for us 400-600 lines, in actual million lines of code to be compiled), the buffer helps. 

Please inform me if any discrepancy is observed in the testcases uploaded here.